<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Ansible Playbook Generator</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    :root {
      --bg: #050810;
      --panel: #0f172a;
      --panel-alt: #020617;
      --border: #1f2937;
      --accent: #38bdf8;
      --accent-soft: rgba(56,189,248,0.12);
      --text: #e5e7eb;
      --text-muted: #9ca3af;
      --danger: #f97373;
      --radius-lg: 14px;
      --radius-md: 10px;
      --radius-sm: 6px;
      --shadow-soft: 0 18px 45px rgba(15,23,42,0.9);
      --shadow-subtle: 0 10px 30px rgba(15,23,42,0.55);
      --font-mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      padding: 16px;
      background: radial-gradient(circle at top, #020617 0, #020617 180px, #020617 200px, #000 500px);
      background-color: var(--bg);
      color: var(--text);
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    .app {
      max-width: 1440px;
      margin: 0 auto;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .app-header {
      display: flex;
      justify-content: space-between;
      gap: 12px;
      align-items: flex-end;
      padding: 14px 18px;
      background: linear-gradient(135deg, #020617 0, #020617 40%, #020617 65%, #020617 100%);
      border-radius: 18px;
      border: 1px solid rgba(148,163,184,0.24);
      box-shadow: var(--shadow-soft);
      position: relative;
      overflow: hidden;
    }

    .app-header::before {
      content: "";
      position: absolute;
      inset: -120px;
      background:
        radial-gradient(circle at 0% 0%, rgba(56,189,248,0.32) 0, transparent 55%),
        radial-gradient(circle at 100% 100%, rgba(129,140,248,0.26) 0, transparent 50%);
      mix-blend-mode: screen;
      opacity: 0.6;
      pointer-events: none;
    }

    .app-header-main {
      position: relative;
      z-index: 1;
    }

    .app-title {
      font-size: 20px;
      font-weight: 600;
      letter-spacing: 0.03em;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .pill {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      padding: 3px 7px;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.6);
      color: var(--text-muted);
      background: rgba(15,23,42,0.7);
    }

    .app-subtitle {
      margin-top: 4px;
      font-size: 12px;
      color: var(--text-muted);
      max-width: 640px;
    }

    .app-header-controls {
      position: relative;
      z-index: 1;
      display: flex;
      flex-direction: column;
      gap: 8px;
      align-items: flex-end;
    }

    .format-toggle {
      display: inline-flex;
      padding: 3px;
      border-radius: 999px;
      background: rgba(15,23,42,0.9);
      border: 1px solid rgba(148,163,184,0.35);
    }

    .format-toggle button {
      border: none;
      background: transparent;
      color: var(--text-muted);
      font-size: 11px;
      padding: 4px 9px;
      border-radius: 999px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .format-toggle button.active {
      background: var(--accent-soft);
      color: var(--accent);
      font-weight: 500;
    }

    .format-toggle button span.icon {
      font-size: 13px;
    }

    .hint-chip {
      font-size: 10px;
      color: var(--text-muted);
      display: flex;
      align-items: center;
      gap: 4px;
      opacity: 0.9;
    }

    .hint-chip .dot {
      width: 5px;
      height: 5px;
      border-radius: 999px;
      background: var(--accent);
      box-shadow: 0 0 10px rgba(56,189,248,0.9);
    }

    .grid {
      display: grid;
      grid-template-columns: minmax(260px, 320px) minmax(260px, 380px) minmax(360px, 1fr);
      gap: 14px;
      align-items: flex-start;
    }

    @media (max-width: 1080px) {
      .grid {
        grid-template-columns: 1fr 1fr;
      }
    }

    @media (max-width: 840px) {
      .grid {
        grid-template-columns: 1fr;
      }
    }

    .panel {
      background: radial-gradient(circle at top left, rgba(15,23,42,0.95) 0, #020617 60%, #020617 100%);
      border-radius: var(--radius-lg);
      border: 1px solid rgba(15,23,42,0.95);
      box-shadow: var(--shadow-subtle);
      padding: 12px 14px;
      position: relative;
      overflow: hidden;
    }

    .panel::before {
      content: "";
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at top, rgba(15,23,42,0.9) 0, transparent 55%);
      opacity: 0.9;
      pointer-events: none;
    }

    .panel-inner {
      position: relative;
      z-index: 1;
    }

    .panel-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }

    .panel-title {
      font-size: 13px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: #9ca3af;
    }

    .badge {
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.55);
      color: var(--text-muted);
    }

    .field {
      display: flex;
      flex-direction: column;
      gap: 4px;
      margin-bottom: 8px;
    }

    .field-label-row {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 8px;
    }

    .field label {
      font-size: 12px;
      color: #d1d5db;
    }

    .field .hint {
      font-size: 11px;
      color: var(--text-muted);
    }

    select,
    input[type="text"],
    input[type="number"] {
      background: rgba(15,23,42,0.9);
      border-radius: var(--radius-md);
      border: 1px solid rgba(31,41,55,0.95);
      padding: 6px 8px;
      font-size: 12px;
      color: var(--text);
      outline: none;
      width: 100%;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    select:focus,
    input[type="text"]:focus,
    input[type="number"]:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px rgba(56,189,248,0.45);
    }

    .input-inline {
      display: flex;
      gap: 6px;
    }

    .pill-row {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 4px;
    }

    .tiny-pill {
      font-size: 10px;
      padding: 2px 5px;
      border-radius: 999px;
      border: 1px solid rgba(55,65,81,0.9);
      color: var(--text-muted);
      background: rgba(15,23,42,0.9);
    }

    .button-row {
      margin-top: 10px;
      display: flex;
      justify-content: flex-end;
      gap: 6px;
    }

    button {
      font-family: inherit;
    }

    .btn {
      border-radius: 999px;
      font-size: 12px;
      padding: 6px 10px;
      border: 1px solid rgba(31,41,55,0.95);
      background: rgba(15,23,42,0.95);
      color: var(--text);
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      transition: background 0.15s ease, border-color 0.15s ease, transform 0.12s ease;
    }

    .btn-primary {
      border-color: rgba(56,189,248,0.85);
      background: radial-gradient(circle at top, rgba(56,189,248,0.35) 0, rgba(8,47,73,0.9) 60%, #020617 100%);
      color: #e0f2fe;
    }

    .btn:hover {
      transform: translateY(-0.5px);
      border-color: rgba(148,163,184,0.9);
    }

    .btn-primary:hover {
      border-color: rgba(56,189,248,1);
      box-shadow: 0 0 18px rgba(56,189,248,0.55);
    }

    .btn-ghost {
      border-style: dashed;
      border-color: rgba(55,65,81,0.9);
      color: var(--text-muted);
    }

    .btn-sm {
      padding: 4px 8px;
      font-size: 11px;
    }

    .btn-icon {
      width: 22px;
      height: 22px;
      border-radius: 999px;
      padding: 0;
      justify-content: center;
    }

    .btn-icon span {
      font-size: 14px;
    }

    .code-panel {
      background: linear-gradient(145deg, #020617 0, #020617 40%, #020617 100%);
      border-radius: var(--radius-lg);
      border: 1px solid rgba(15,23,42,0.95);
      box-shadow: var(--shadow-soft);
      padding: 10px 12px;
      position: relative;
      overflow: hidden;
    }

    .code-panel::before {
      content: "";
      position: absolute;
      inset: -150px;
      background:
        radial-gradient(circle at 0% 0%, rgba(56,189,248,0.18) 0, transparent 50%),
        radial-gradient(circle at 100% 100%, rgba(129,140,248,0.18) 0, transparent 50%);
      opacity: 0.9;
      mix-blend-mode: screen;
      pointer-events: none;
    }

    .code-panel-inner {
      position: relative;
      z-index: 1;
    }

    .code-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 6px;
      gap: 8px;
    }

    .code-header-left {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .code-header-title {
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: #9ca3af;
    }

    .code-meta {
      font-size: 10px;
      color: var(--text-muted);
    }

    .code-actions {
      display: flex;
      gap: 6px;
    }

    pre {
      margin: 0;
      padding: 10px 10px;
      border-radius: var(--radius-md);
      background: rgba(15,23,42,0.96);
      border: 1px solid rgba(31,41,55,0.95);
      font-family: var(--font-mono);
      font-size: 11px;
      color: #e5e7eb;
      max-height: 420px;
      overflow: auto;
      white-space: pre;
    }

    .command-bar {
      margin-top: 6px;
      padding: 6px 8px;
      border-radius: var(--radius-md);
      background: rgba(15,23,42,0.9);
      border: 1px dashed rgba(55,65,81,0.9);
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
    }

    .command-text {
      font-family: var(--font-mono);
      font-size: 11px;
      color: #9ca3af;
      overflow-x: auto;
      white-space: nowrap;
    }

    .status-line {
      margin-top: 4px;
      font-size: 11px;
      color: var(--text-muted);
      display: flex;
      align-items: center;
      gap: 5px;
    }

    .status-dot {
      width: 6px;
      height: 6px;
      border-radius: 999px;
      background: rgba(74,222,128,0.95);
      box-shadow: 0 0 10px rgba(74,222,128,0.75);
    }

    .status-dot.error {
      background: var(--danger);
      box-shadow: 0 0 10px rgba(248,113,113,0.85);
    }

    .error-text {
      color: var(--danger);
    }
  </style>
</head>
<body>
<div class="app">
  <header class="app-header">
    <div class="app-header-main">
      <div class="app-title">
        <span>ANSIBLE PLAYBOOK GENERATOR</span>
        <span class="pill">Multi-Cloud ¬∑ Scripts ¬∑ Playbooks</span>
      </div>
      <p class="app-subtitle">
        Pick platform ‚Üí service / blueprint ‚Üí inputs. The generator builds a ready-to-run Ansible playbook and can emit YAML or JSON.
        Platforms include AWS, Azure, Google Cloud, Oracle, VMware, plus generic Linux/Windows config.
      </p>
    </div>
    <div class="app-header-controls">
      <div class="format-toggle" id="formatToggle">
        <button type="button" data-format="yaml" class="active">
          <span class="icon">üßæ</span> YAML
        </button>
        <button type="button" data-format="json">
          <span class="icon">{}</span> JSON
        </button>
      </div>
      <div class="hint-chip">
        <span class="dot"></span>
        <span>All templates are data-driven; extend in <code>SCENARIO_DEFS</code>.</span>
      </div>
    </div>
  </header>

  <main class="grid">
    <!-- PLATFORM / SERVICE PICKER -->
    <section class="panel">
      <div class="panel-inner">
        <div class="panel-header">
          <div class="panel-title">Platform &amp; Service / Blueprint</div>
          <div class="badge">Step 1</div>
        </div>

        <div class="field">
          <div class="field-label-row">
            <label for="platformSelect">Target Platform / Provider</label>
            <span class="hint">Cloud or on-prem target</span>
          </div>
          <select id="platformSelect">
            <!-- populated by JS -->
          </select>
          <div class="pill-row">
            <span class="tiny-pill">AWS</span>
            <span class="tiny-pill">Azure</span>
            <span class="tiny-pill">Google Cloud</span>
            <span class="tiny-pill">Oracle Cloud</span>
            <span class="tiny-pill">VMware vSphere</span>
            <span class="tiny-pill">Linux</span>
            <span class="tiny-pill">Windows</span>
          </div>
        </div>

        <div class="field">
          <div class="field-label-row">
            <label for="scenarioSelect">Service / Blueprint</label>
            <span class="hint">What are we trying to do?</span>
          </div>
          <select id="scenarioSelect">
            <!-- populated by JS -->
          </select>
        </div>

        <div class="field">
          <div class="field-label-row">
            <label for="hostsInput">Inventory hosts pattern</label>
            <span class="hint">From your <code>inventory.yml</code></span>
          </div>
          <input id="hostsInput" type="text" value="all" />
        </div>

        <div class="field">
          <div class="field-label-row">
            <label for="filenameInput">Suggested playbook filename</label>
            <span class="hint">Used in CLI hint</span>
          </div>
          <input id="filenameInput" type="text" value="playbook_generated.yml" />
        </div>

        <div class="button-row">
          <button type="button" class="btn btn-ghost btn-sm" id="resetButton">Reset</button>
        </div>
      </div>
    </section>

    <!-- PARAMETER FORM -->
    <section class="panel">
      <div class="panel-inner">
        <div class="panel-header">
          <div class="panel-title">Parameters &amp; Options</div>
          <div class="badge">Step 2</div>
        </div>

        <div id="paramsArea">
          <!-- dynamic inputs rendered here -->
        </div>

        <div class="button-row">
          <button type="button" class="btn btn-primary" id="generateButton">
            <span>‚öôÔ∏è</span>
            <span>Generate Playbook</span>
          </button>
        </div>
      </div>
    </section>

    <!-- GENERATED CODE -->
    <section class="code-panel">
      <div class="code-panel-inner">
        <div class="code-header">
          <div class="code-header-left">
            <div class="code-header-title">Generated Ansible Code</div>
            <div class="code-meta" id="codeMeta">
              Waiting for input‚Ä¶
            </div>
          </div>
          <div class="code-actions">
            <button type="button" class="btn btn-sm" id="downloadButton">
              ‚¨áÔ∏è Download
            </button>
            <button type="button" class="btn btn-icon" id="copyButton" title="Copy to clipboard">
              <span>üìã</span>
            </button>
          </div>
        </div>

        <pre id="outputPre"># Select a platform & service / blueprint, adjust parameters, then click ‚ÄúGenerate Playbook‚Äù.</pre>

        <div class="command-bar">
          <div class="command-text" id="commandHint">
            ansible-playbook -i inventory.yml playbook_generated.yml
          </div>
          <button type="button" class="btn btn-sm btn-ghost" id="copyCommandButton">
            Copy command
          </button>
        </div>

        <div class="status-line" id="statusLine">
          <span class="status-dot"></span>
          <span>Idle ‚Äî no errors.</span>
        </div>
      </div>
    </section>
  </main>
</div>

<script>
  // -----------------------
  // Helper option lists for dropdowns
  // -----------------------
  const AWS_REGIONS = [
    "us-east-1", "us-east-2", "us-west-1", "us-west-2",
    "eu-central-1", "eu-west-1", "eu-west-2",
    "ap-southeast-1", "ap-southeast-2", "ap-northeast-1"
  ];

  const AZURE_LOCATIONS = [
    "eastus", "eastus2", "westus", "westeurope",
    "northeurope", "uksouth", "centralus"
  ];

  const GCP_ZONES = [
    "us-central1-a", "us-central1-b",
    "us-east1-b", "us-east1-c",
    "europe-west1-b", "europe-west1-c"
  ];

  const BOOL_OPTIONS = [
    { value: "true", label: "true" },
    { value: "false", label: "false" }
  ];

  // -----------------------
  // Data model: platforms & services / blueprints
  // -----------------------
const SCENARIO_DEFS = {
    aws: {
      label: "Amazon Web Services (AWS)",
      scenarios: {
        ec2_instance: {
          label: "Provision EC2 instance",
          description: "Create an EC2 instance with a basic security group.",
          inputs: [
            {
              id: "aws_region",
              label: "AWS region",
              control: "select",
              options: AWS_REGIONS.map(r => ({ value: r, label: r })),
              default: "us-east-1",
              hint: "Target region"
            },
            { id: "instance_name", label: "Instance Name tag", type: "text", default: "web-01", hint: "Name tag" },
            {
              id: "instance_type",
              label: "Instance type",
              control: "select",
              options: ["t3.micro", "t3.small", "t3.medium", "t3a.micro", "t3a.small", "t3a.medium"]
                .map(v => ({ value: v, label: v })),
              default: "t3.small",
              hint: "Size"
            },
            { id: "ami_id", label: "AMI ID", type: "text", default: "ami-xxxxxxxx", hint: "AMI ID" },
            { id: "key_name", label: "SSH key name", type: "text", default: "default", hint: "Key pair name" },
            { id: "vpc_subnet_id", label: "Subnet ID", type: "text", default: "subnet-xxxx", hint: "VPC subnet" },
            { id: "security_group_name", label: "Security group name", type: "text", default: "sg-web", hint: "SG name" },
            { id: "allowed_http_cidr", label: "HTTP allowed CIDR", type: "text", default: "0.0.0.0/0", hint: "Lock this down in prod" }
          ],
          buildPlay: (vals, hosts) => ([
            {
              name: "Provision EC2 instance",
              hosts,
              become: false,
              gather_facts: false,
              vars: {
                aws_region: vals.aws_region,
                instance_name: vals.instance_name,
                instance_type: vals.instance_type,
                ami_id: vals.ami_id,
                key_name: vals.key_name,
                vpc_subnet_id: vals.vpc_subnet_id,
                security_group_name: vals.security_group_name,
                allowed_http_cidr: vals.allowed_http_cidr
              },
              tasks: [
                {
                  name: "Ensure security group exists",
                  "amazon.aws.ec2_security_group": {
                    name: "{{ security_group_name }}",
                    description: "Web security group",
                    region: "{{ aws_region }}",
                    rules: [
                      { proto: "tcp", from_port: 22, to_port: 22, cidr_ip: "0.0.0.0/0" },
                      { proto: "tcp", from_port: 80, to_port: 80, cidr_ip: "{{ allowed_http_cidr }}" }
                    ]
                  }
                },
                {
                  name: "Launch EC2 instance",
                  "amazon.aws.ec2_instance": {
                    name: "{{ instance_name }}",
                    region: "{{ aws_region }}",
                    image_id: "{{ ami_id }}",
                    instance_type: "{{ instance_type }}",
                    key_name: "{{ key_name }}",
                    vpc_subnet_id: "{{ vpc_subnet_id }}",
                    security_group: "{{ security_group_name }}",
                    wait: true
                  }
                }
              ]
            }
          ])
        },

        s3_bucket: {
          label: "Create S3 bucket",
          description: "Create S3 bucket with versioning and encryption.",
          inputs: [
            {
              id: "aws_region",
              label: "AWS region",
              control: "select",
              options: AWS_REGIONS.map(r => ({ value: r, label: r })),
              default: "us-east-1",
              hint: "Bucket region"
            },
            { id: "bucket_name", label: "Bucket name", type: "text", default: "court-archive-bucket", hint: "Globally unique" },
            {
              id: "enable_versioning",
              label: "Enable versioning",
              control: "select",
              options: BOOL_OPTIONS,
              default: "true",
              hint: "true / false"
            },
            {
              id: "sse_algorithm",
              label: "SSE algorithm",
              control: "select",
              options: [
                { value: "AES256", label: "AES256" },
                { value: "aws:kms", label: "aws:kms" }
              ],
              default: "AES256",
              hint: "Encryption"
            }
          ],
          buildPlay: (vals, hosts) => ([
            {
              name: "Create S3 bucket",
              hosts,
              become: false,
              gather_facts: false,
              vars: {
                aws_region: vals.aws_region,
                bucket_name: vals.bucket_name,
                enable_versioning: vals.enable_versioning === "true",
                sse_algorithm: vals.sse_algorithm
              },
              tasks: [
                {
                  name: "Create bucket",
                  "amazon.aws.s3_bucket": {
                    name: "{{ bucket_name }}",
                    state: "present",
                    region: "{{ aws_region }}"
                  }
                },
                {
                  name: "Configure versioning",
                  "amazon.aws.s3_bucket": {
                    name: "{{ bucket_name }}",
                    region: "{{ aws_region }}",
                    versioning: { Status: "{{ 'Enabled' if enable_versioning else 'Suspended' }}" }
                  }
                },
                {
                  name: "Configure default encryption",
                  "amazon.aws.s3_bucket": {
                    name: "{{ bucket_name }}",
                    region: "{{ aws_region }}",
                    encryption_configuration: {
                      Rules: [
                        {
                          ApplyServerSideEncryptionByDefault: {
                            SSEAlgorithm: "{{ sse_algorithm }}"
                          }
                        }
                      ]
                    }
                  }
                }
              ]
            }
          ])
        },

        vpc_baseline: {
          label: "Create VPC + subnets",
          description: "Baseline VPC with public/private subnets and an Internet Gateway.",
          inputs: [
            {
              id: "aws_region",
              label: "AWS region",
              control: "select",
              options: AWS_REGIONS.map(r => ({ value: r, label: r })),
              default: "us-east-1",
              hint: "Region"
            },
            { id: "vpc_cidr", label: "VPC CIDR", type: "text", default: "10.0.0.0/16", hint: "CIDR block" },
            { id: "public_cidr", label: "Public subnet CIDR", type: "text", default: "10.0.1.0/24", hint: "Public subnet" },
            { id: "private_cidr", label: "Private subnet CIDR", type: "text", default: "10.0.2.0/24", hint: "Private subnet" },
            { id: "name_prefix", label: "Name prefix", type: "text", default: "court-vpc", hint: "Tag prefix" }
          ],
          buildPlay: (vals, hosts) => ([
            {
              name: "Create baseline VPC",
              hosts,
              become: false,
              gather_facts: false,
              vars: {
                aws_region: vals.aws_region,
                vpc_cidr: vals.vpc_cidr,
                public_cidr: vals.public_cidr,
                private_cidr: vals.private_cidr,
                name_prefix: vals.name_prefix
              },
              tasks: [
                {
                  name: "Create VPC",
                  "amazon.aws.ec2_vpc_net": {
                    name: "{{ name_prefix }}",
                    cidr_block: "{{ vpc_cidr }}",
                    region: "{{ aws_region }}",
                    tags: { Name: "{{ name_prefix }}" }
                  },
                  register: "vpc"
                },
                {
                  name: "Create Internet Gateway",
                  "amazon.aws.ec2_vpc_igw": {
                    vpc_id: "{{ vpc.vpc.id }}",
                    region: "{{ aws_region }}",
                    state: "present",
                    tags: { Name: "{{ name_prefix }}-igw" }
                  },
                  register: "igw"
                },
                {
                  name: "Create public subnet",
                  "amazon.aws.ec2_vpc_subnet": {
                    vpc_id: "{{ vpc.vpc.id }}",
                    cidr: "{{ public_cidr }}",
                    az: "{{ aws_region }}a",
                    map_public: true,
                    region: "{{ aws_region }}",
                    tags: { Name: "{{ name_prefix }}-public" }
                  },
                  register: "public_subnet"
                },
                {
                  name: "Create private subnet",
                  "amazon.aws.ec2_vpc_subnet": {
                    vpc_id: "{{ vpc.vpc.id }}",
                    cidr: "{{ private_cidr }}",
                    az: "{{ aws_region }}b",
                    region: "{{ aws_region }}",
                    tags: { Name: "{{ name_prefix }}-private" }
                  },
                  register: "private_subnet"
                },
                {
                  name: "Create public route table",
                  "amazon.aws.ec2_vpc_route_table": {
                    vpc_id: "{{ vpc.vpc.id }}",
                    region: "{{ aws_region }}",
                    tags: { Name: "{{ name_prefix }}-public-rt" },
                    subnets: ["{{ public_subnet.subnet.id }}"],
                    routes: [
                      { dest: "0.0.0.0/0", gateway_id: "{{ igw.gateway_id }}" }
                    ]
                  }
                }
              ]
            }
          ])
        },

        // ------------------------
        // NEW AWS BLUEPRINTS
        // ------------------------

        rds_instance: {
          label: "RDS ‚Äì Database instance",
          description: "Create an RDS instance for a relational database.",
          inputs: [
            {
              id: "aws_region",
              label: "AWS region",
              control: "select",
              options: AWS_REGIONS.map(r => ({ value: r, label: r })),
              default: "us-east-1",
              hint: "Region"
            },
            { id: "db_identifier", label: "DB identifier", type: "text", default: "court-rds-01", hint: "Instance ID" },
            {
              id: "engine",
              label: "Engine",
              control: "select",
              options: [
                { value: "mysql", label: "MySQL" },
                { value: "postgres", label: "PostgreSQL" },
                { value: "oracle-ee", label: "Oracle EE" }
              ],
              default: "postgres",
              hint: "DB engine"
            },
            { id: "engine_version", label: "Engine version", type: "text", default: "15", hint: "e.g. 15, 8.0.36" },
            {
              id: "instance_class",
              label: "Instance class",
              control: "select",
              options: [
                "db.t3.micro",
                "db.t3.small",
                "db.t3.medium",
                "db.m5.large"
              ].map(v => ({ value: v, label: v })),
              default: "db.t3.small",
              hint: "Size"
            },
            { id: "allocated_storage", label: "Storage (GB)", type: "number", default: 20, hint: "Initial storage" },
            { id: "master_username", label: "Master username", type: "text", default: "dbadmin", hint: "Admin user" },
            { id: "master_password", label: "Master password", type: "text", default: "ChangeMe123!", hint: "Use a secret in real life" },
            {
              id: "publicly_accessible",
              label: "Publicly accessible",
              control: "select",
              options: BOOL_OPTIONS,
              default: "false",
              hint: "true / false"
            },
            {
              id: "multi_az",
              label: "Multi-AZ",
              control: "select",
              options: BOOL_OPTIONS,
              default: "true",
              hint: "Enable Multi-AZ"
            }
          ],
          buildPlay: (vals, hosts) => ([
            {
              name: "Provision RDS instance",
              hosts,
              become: false,
              gather_facts: false,
              vars: {
                aws_region: vals.aws_region,
                db_identifier: vals.db_identifier,
                engine: vals.engine,
                engine_version: vals.engine_version,
                instance_class: vals.instance_class,
                allocated_storage: Number(vals.allocated_storage),
                master_username: vals.master_username,
                master_password: vals.master_password,
                publicly_accessible: vals.publicly_accessible === "true",
                multi_az: vals.multi_az === "true"
              },
              tasks: [
                {
                  name: "Create RDS instance",
                  "amazon.aws.rds_instance": {
                    region: "{{ aws_region }}",
                    db_instance_identifier: "{{ db_identifier }}",
                    engine: "{{ engine }}",
                    engine_version: "{{ engine_version }}",
                    db_instance_class: "{{ instance_class }}",
                    allocated_storage: "{{ allocated_storage }}",
                    master_username: "{{ master_username }}",
                    master_user_password: "{{ master_password }}",
                    multi_az: "{{ multi_az }}",
                    publicly_accessible: "{{ publicly_accessible }}"
                  }
                }
              ]
            }
          ])
        },

        dynamodb_table: {
          label: "DynamoDB ‚Äì Table",
          description: "Create a DynamoDB table with a simple key schema.",
          inputs: [
            {
              id: "aws_region",
              label: "AWS region",
              control: "select",
              options: AWS_REGIONS.map(r => ({ value: r, label: r })),
              default: "us-east-1",
              hint: "Region"
            },
            { id: "table_name", label: "Table name", type: "text", default: "CourtSessions", hint: "DynamoDB table name" },
            { id: "hash_key_name", label: "Partition key name", type: "text", default: "CaseId", hint: "Hash key" },
            {
              id: "billing_mode",
              label: "Billing mode",
              control: "select",
              options: [
                { value: "PAY_PER_REQUEST", label: "On-demand" },
                { value: "PROVISIONED", label: "Provisioned" }
              ],
              default: "PAY_PER_REQUEST",
              hint: "Capacity mode"
            }
          ],
          buildPlay: (vals, hosts) => ([
            {
              name: "Create DynamoDB table",
              hosts,
              become: false,
              gather_facts: false,
              vars: {
                aws_region: vals.aws_region,
                table_name: vals.table_name,
                hash_key_name: vals.hash_key_name,
                billing_mode: vals.billing_mode
              },
              tasks: [
                {
                  name: "Ensure DynamoDB table exists",
                  "amazon.aws.dynamodb_table": {
                    name: "{{ table_name }}",
                    region: "{{ aws_region }}",
                    hash_key_name: "{{ hash_key_name }}",
                    hash_key_type: "S",
                    billing_mode: "{{ billing_mode }}"
                  }
                }
              ]
            }
          ])
        },

        sns_topic: {
          label: "SNS ‚Äì Topic + subscription",
          description: "Create an SNS topic and subscribe an email endpoint.",
          inputs: [
            {
              id: "aws_region",
              label: "AWS region",
              control: "select",
              options: AWS_REGIONS.map(r => ({ value: r, label: r })),
              default: "us-east-1",
              hint: "Region"
            },
            { id: "topic_name", label: "Topic name", type: "text", default: "court-notifications", hint: "Topic name" },
            { id: "subscription_email", label: "Subscriber email", type: "text", default: "alerts@example.org", hint: "Email endpoint" }
          ],
          buildPlay: (vals, hosts) => ([
            {
              name: "Create SNS topic and subscription",
              hosts,
              become: false,
              gather_facts: false,
              vars: {
                aws_region: vals.aws_region,
                topic_name: vals.topic_name,
                subscription_email: vals.subscription_email
              },
              tasks: [
                {
                  name: "Create SNS topic",
                  "amazon.aws.sns_topic": {
                    name: "{{ topic_name }}",
                    region: "{{ aws_region }}"
                  },
                  register: "topic"
                },
                {
                  name: "Subscribe email",
                  "amazon.aws.sns_subscription": {
                    topic_arn: "{{ topic.topic_arn }}",
                    protocol: "email",
                    endpoint: "{{ subscription_email }}"
                  }
                }
              ]
            }
          ])
        },

        sqs_queue: {
          label: "SQS ‚Äì Queue",
          description: "Create an SQS queue for asynchronous workloads.",
          inputs: [
            {
              id: "aws_region",
              label: "AWS region",
              control: "select",
              options: AWS_REGIONS.map(r => ({ value: r, label: r })),
              default: "us-east-1",
              hint: "Region"
            },
            { id: "queue_name", label: "Queue name", type: "text", default: "court-jobs-queue", hint: "Queue name" },
            {
              id: "visibility_timeout",
              label: "Visibility timeout (sec)",
              type: "number",
              default: 30,
              hint: "Default visibility timeout"
            }
          ],
          buildPlay: (vals, hosts) => ([
            {
              name: "Create SQS queue",
              hosts,
              become: false,
              gather_facts: false,
              vars: {
                aws_region: vals.aws_region,
                queue_name: vals.queue_name,
                visibility_timeout: Number(vals.visibility_timeout)
              },
              tasks: [
                {
                  name: "Ensure SQS queue exists",
                  "amazon.aws.sqs_queue": {
                    name: "{{ queue_name }}",
                    region: "{{ aws_region }}",
                    visibility_timeout: "{{ visibility_timeout }}"
                  }
                }
              ]
            }
          ])
        },

        kms_key: {
          label: "KMS ‚Äì Customer managed key",
          description: "Create a KMS CMK for encrypting court workloads.",
          inputs: [
            {
              id: "aws_region",
              label: "AWS region",
              control: "select",
              options: AWS_REGIONS.map(r => ({ value: r, label: r })),
              default: "us-east-1",
              hint: "Region"
            },
            { id: "key_alias", label: "Key alias", type: "text", default: "alias/court-data-key", hint: "Alias name" },
            { id: "description", label: "Key description", type: "text", default: "Court data encryption key", hint: "Description" }
          ],
          buildPlay: (vals, hosts) => ([
            {
              name: "Create KMS key",
              hosts,
              become: false,
              gather_facts: false,
              vars: {
                aws_region: vals.aws_region,
                key_alias: vals.key_alias,
                description: vals.description
              },
              tasks: [
                {
                  name: "Create CMK",
                  "amazon.aws.kms_key": {
                    state: "present",
                    alias: "{{ key_alias }}",
                    description: "{{ description }}",
                    region: "{{ aws_region }}"
                  }
                }
              ]
            }
          ])
        },

        cloudwatch_alarm: {
          label: "CloudWatch ‚Äì CPU alarm",
          description: "Create a CPUUtilization alarm for an EC2 instance.",
          inputs: [
            {
              id: "aws_region",
              label: "AWS region",
              control: "select",
              options: AWS_REGIONS.map(r => ({ value: r, label: r })),
              default: "us-east-1",
              hint: "Region"
            },
            { id: "alarm_name", label: "Alarm name", type: "text", default: "HighCPU", hint: "Alarm name" },
            { id: "instance_id", label: "Instance ID", type: "text", default: "i-xxxxxxxx", hint: "Target EC2 instance" },
            {
              id: "threshold",
              label: "Threshold (%)",
              type: "number",
              default: 80,
              hint: "CPU threshold"
            },
            {
              id: "evaluation_periods",
              label: "Evaluation periods",
              type: "number",
              default: 3,
              hint: "Number of periods"
            }
          ],
          buildPlay: (vals, hosts) => ([
            {
              name: "Create CloudWatch CPU alarm",
              hosts,
              become: false,
              gather_facts: false,
              vars: {
                aws_region: vals.aws_region,
                alarm_name: vals.alarm_name,
                instance_id: vals.instance_id,
                threshold: Number(vals.threshold),
                evaluation_periods: Number(vals.evaluation_periods)
              },
              tasks: [
                {
                  name: "Ensure CPU alarm exists",
                  "amazon.aws.cloudwatch_metric_alarm": {
                    name: "{{ alarm_name }}",
                    region: "{{ aws_region }}",
                    state: "present",
                    metric: "CPUUtilization",
                    namespace: "AWS/EC2",
                    statistic: "Average",
                    comparison: ">=",
                    threshold: "{{ threshold }}",
                    period: 300,
                    evaluation_periods: "{{ evaluation_periods }}",
                    dimensions: {
                      InstanceId: "{{ instance_id }}"
                    }
                  }
                }
              ]
            }
          ])
        },

        cloudtrail_trail: {
          label: "CloudTrail ‚Äì Organization trail",
          description: "Create or ensure a CloudTrail trail for auditing API calls.",
          inputs: [
            {
              id: "aws_region",
              label: "Home region",
              control: "select",
              options: AWS_REGIONS.map(r => ({ value: r, label: r })),
              default: "us-east-1",
              hint: "Trail home region"
            },
            { id: "trail_name", label: "Trail name", type: "text", default: "org-audit-trail", hint: "CloudTrail name" },
            { id: "s3_bucket_name", label: "S3 bucket for logs", type: "text", default: "court-cloudtrail-logs", hint: "Bucket must exist or be created" },
            {
              id: "is_multi_region",
              label: "Multi-region",
              control: "select",
              options: BOOL_OPTIONS,
              default: "true",
              hint: "Record in all regions"
            }
          ],
          buildPlay: (vals, hosts) => ([
            {
              name: "Configure CloudTrail trail",
              hosts,
              become: false,
              gather_facts: false,
              vars: {
                aws_region: vals.aws_region,
                trail_name: vals.trail_name,
                s3_bucket_name: vals.s3_bucket_name,
                is_multi_region: vals.is_multi_region === "true"
              },
              tasks: [
                {
                  name: "Ensure CloudTrail trail exists",
                  "amazon.aws.cloudtrail": {
                    name: "{{ trail_name }}",
                    region: "{{ aws_region }}",
                    s3_bucket_name: "{{ s3_bucket_name }}",
                    is_multi_region_trail: "{{ is_multi_region }}"
                  }
                }
              ]
            }
          ])
        }
      }
    },

   azure: {
      label: "Microsoft Azure",
      scenarios: {
        vm_linux: {
          label: "Compute ‚Äì Linux VM",
          description: "Create a Linux VM, NIC and basic network resources.",
          inputs: [
            {
              id: "azure_location",
              label: "Azure location",
              control: "select",
              options: AZURE_LOCATIONS.map(l => ({ value: l, label: l })),
              default: "eastus",
              hint: "Region"
            },
            { id: "resource_group", label: "Resource group", type: "text", default: "rg-ansible-demo", hint: "Existing or to create" },
            { id: "vm_name", label: "VM name", type: "text", default: "vm-linux-01", hint: "Name of the VM" },
            { id: "vm_size", label: "VM size", type: "text", default: "Standard_B2s", hint: "e.g. Standard_B2s" },
            { id: "admin_username", label: "Admin username", type: "text", default: "azureuser", hint: "SSH user" }
          ],
          buildPlay: (vals, hosts) => {
            return [
              {
                name: "Provision Azure Linux VM",
                hosts,
                become: false,
                gather_facts: false,
                vars: {
                  azure_location: vals.azure_location,
                  resource_group: vals.resource_group,
                  vm_name: vals.vm_name,
                  vm_size: vals.vm_size,
                  admin_username: vals.admin_username
                },
                tasks: [
                  {
                    name: "Ensure resource group exists",
                    "azure.azcollection.azure_rm_resourcegroup": {
                      name: "{{ resource_group }}",
                      location: "{{ azure_location }}"
                    }
                  },
                  {
                    name: "Ensure virtual network exists",
                    "azure.azcollection.azure_rm_virtualnetwork": {
                      resource_group: "{{ resource_group }}",
                      name: "{{ resource_group }}-vnet",
                      address_prefixes: ["10.10.0.0/16"]
                    }
                  },
                  {
                    name: "Ensure subnet exists",
                    "azure.azcollection.azure_rm_subnet": {
                      resource_group: "{{ resource_group }}",
                      name: "{{ resource_group }}-subnet",
                      address_prefix: "10.10.1.0/24",
                      virtual_network: "{{ resource_group }}-vnet"
                    }
                  },
                  {
                    name: "Create public IP",
                    "azure.azcollection.azure_rm_publicipaddress": {
                      resource_group: "{{ resource_group }}",
                      allocation_method: "Static",
                      name: "{{ vm_name }}-pip"
                    }
                  },
                  {
                    name: "Create NIC",
                    "azure.azcollection.azure_rm_networkinterface": {
                      resource_group: "{{ resource_group }}",
                      name: "{{ vm_name }}-nic",
                      virtual_network: "{{ resource_group }}-vnet",
                      subnet: "{{ resource_group }}-subnet",
                      public_ip_name: "{{ vm_name }}-pip"
                    }
                  },
                  {
                    name: "Provision Azure VM",
                    "azure.azcollection.azure_rm_virtualmachine": {
                      resource_group: "{{ resource_group }}",
                      name: "{{ vm_name }}",
                      vm_size: "{{ vm_size }}",
                      admin_username: "{{ admin_username }}",
                      network_interfaces: ["{{ vm_name }}-nic"],
                      image: {
                        offer: "0001-com-ubuntu-server-focal",
                        publisher: "Canonical",
                        sku: "20_04-lts",
                        version: "latest"
                      }
                    }
                  }
                ]
              }
            ];
          }
        },

        vm_windows: {
          label: "Compute ‚Äì Windows VM",
          description: "Create a Windows VM in Azure with basic network resources.",
          inputs: [
            {
              id: "azure_location",
              label: "Azure location",
              control: "select",
              options: AZURE_LOCATIONS.map(l => ({ value: l, label: l })),
              default: "eastus",
              hint: "Region"
            },
            { id: "resource_group", label: "Resource group", type: "text", default: "rg-win-servers", hint: "Existing or to create" },
            { id: "vm_name", label: "VM name", type: "text", default: "vm-win-01", hint: "Name of the VM" },
            { id: "vm_size", label: "VM size", type: "text", default: "Standard_B2ms", hint: "e.g. Standard_B2ms" },
            { id: "admin_username", label: "Admin username", type: "text", default: "azureadmin", hint: "Local admin user" },
            { id: "admin_password", label: "Admin password", type: "text", default: "CHANGE_ME!", hint: "Use secret in real life" }
          ],
          buildPlay: (vals, hosts) => {
            return [
              {
                name: "Provision Azure Windows VM",
                hosts,
                become: false,
                gather_facts: false,
                vars: {
                  azure_location: vals.azure_location,
                  resource_group: vals.resource_group,
                  vm_name: vals.vm_name,
                  vm_size: vals.vm_size,
                  admin_username: vals.admin_username,
                  admin_password: vals.admin_password
                },
                tasks: [
                  {
                    name: "Ensure resource group exists",
                    "azure.azcollection.azure_rm_resourcegroup": {
                      name: "{{ resource_group }}",
                      location: "{{ azure_location }}"
                    }
                  },
                  {
                    name: "Ensure virtual network exists",
                    "azure.azcollection.azure_rm_virtualnetwork": {
                      resource_group: "{{ resource_group }}",
                      name: "{{ resource_group }}-vnet",
                      address_prefixes: ["10.20.0.0/16"]
                    }
                  },
                  {
                    name: "Ensure subnet exists",
                    "azure.azcollection.azure_rm_subnet": {
                      resource_group: "{{ resource_group }}",
                      name: "{{ resource_group }}-subnet",
                      address_prefix: "10.20.1.0/24",
                      virtual_network: "{{ resource_group }}-vnet"
                    }
                  },
                  {
                    name: "Create public IP",
                    "azure.azcollection.azure_rm_publicipaddress": {
                      resource_group: "{{ resource_group }}",
                      allocation_method: "Static",
                      name: "{{ vm_name }}-pip"
                    }
                  },
                  {
                    name: "Create NIC",
                    "azure.azcollection.azure_rm_networkinterface": {
                      resource_group: "{{ resource_group }}",
                      name: "{{ vm_name }}-nic",
                      virtual_network: "{{ resource_group }}-vnet",
                      subnet: "{{ resource_group }}-subnet",
                      public_ip_name: "{{ vm_name }}-pip"
                    }
                  },
                  {
                    name: "Provision Azure Windows VM",
                    "azure.azcollection.azure_rm_virtualmachine": {
                      resource_group: "{{ resource_group }}",
                      name: "{{ vm_name }}",
                      vm_size: "{{ vm_size }}",
                      admin_username: "{{ admin_username }}",
                      admin_password: "{{ admin_password }}",
                      os_type: "Windows",
                      network_interfaces: ["{{ vm_name }}-nic"],
                      image: {
                        offer: "WindowsServer",
                        publisher: "MicrosoftWindowsServer",
                        sku: "2019-Datacenter",
                        version: "latest"
                      }
                    }
                  }
                ]
              }
            ];
          }
        },

        vnet_baseline: {
          label: "Network ‚Äì VNet + subnets",
          description: "Create a VNet with public/private subnets.",
          inputs: [
            {
              id: "azure_location",
              label: "Azure location",
              control: "select",
              options: AZURE_LOCATIONS.map(l => ({ value: l, label: l })),
              default: "eastus",
              hint: "Region"
            },
            { id: "resource_group", label: "Resource group", type: "text", default: "rg-network", hint: "Resource group" },
            { id: "vnet_name", label: "VNet name", type: "text", default: "court-vnet", hint: "Virtual network name" },
            { id: "address_prefix", label: "VNet address prefix", type: "text", default: "10.30.0.0/16", hint: "CIDR" },
            { id: "public_subnet_prefix", label: "Public subnet prefix", type: "text", default: "10.30.1.0/24", hint: "CIDR" },
            { id: "private_subnet_prefix", label: "Private subnet prefix", type: "text", default: "10.30.2.0/24", hint: "CIDR" }
          ],
          buildPlay: (vals, hosts) => {
            return [
              {
                name: "Create Azure VNet and subnets",
                hosts,
                become: false,
                gather_facts: false,
                vars: {
                  azure_location: vals.azure_location,
                  resource_group: vals.resource_group,
                  vnet_name: vals.vnet_name,
                  address_prefix: vals.address_prefix,
                  public_subnet_prefix: vals.public_subnet_prefix,
                  private_subnet_prefix: vals.private_subnet_prefix
                },
                tasks: [
                  {
                    name: "Ensure resource group exists",
                    "azure.azcollection.azure_rm_resourcegroup": {
                      name: "{{ resource_group }}",
                      location: "{{ azure_location }}"
                    }
                  },
                  {
                    name: "Create VNet",
                    "azure.azcollection.azure_rm_virtualnetwork": {
                      resource_group: "{{ resource_group }}",
                      name: "{{ vnet_name }}",
                      address_prefixes: ["{{ address_prefix }}"]
                    }
                  },
                  {
                    name: "Create public subnet",
                    "azure.azcollection.azure_rm_subnet": {
                      resource_group: "{{ resource_group }}",
                      name: "{{ vnet_name }}-public",
                      address_prefix: "{{ public_subnet_prefix }}",
                      virtual_network: "{{ vnet_name }}"
                    }
                  },
                  {
                    name: "Create private subnet",
                    "azure.azcollection.azure_rm_subnet": {
                      resource_group: "{{ resource_group }}",
                      name: "{{ vnet_name }}-private",
                      address_prefix: "{{ private_subnet_prefix }}",
                      virtual_network: "{{ vnet_name }}"
                    }
                  }
                ]
              }
            ];
          }
        },

        storage_account: {
          label: "Storage ‚Äì Account & container",
          description: "Create a Storage Account and a Blob container.",
          inputs: [
            {
              id: "azure_location",
              label: "Azure location",
              control: "select",
              options: AZURE_LOCATIONS.map(l => ({ value: l, label: l })),
              default: "eastus",
              hint: "Region"
            },
            { id: "resource_group", label: "Resource group", type: "text", default: "rg-storage", hint: "Resource group" },
            { id: "account_name", label: "Storage account name", type: "text", default: "courtarchive001", hint: "Globally unique" },
            { id: "container_name", label: "Container name", type: "text", default: "documents", hint: "Blob container" }
          ],
          buildPlay: (vals, hosts) => {
            return [
              {
                name: "Create Storage account and container",
                hosts,
                become: false,
                gather_facts: false,
                vars: {
                  azure_location: vals.azure_location,
                  resource_group: vals.resource_group,
                  account_name: vals.account_name,
                  container_name: vals.container_name
                },
                tasks: [
                  {
                    name: "Ensure resource group exists",
                    "azure.azcollection.azure_rm_resourcegroup": {
                      name: "{{ resource_group }}",
                      location: "{{ azure_location }}"
                    }
                  },
                  {
                    name: "Create storage account",
                    "azure.azcollection.azure_rm_storageaccount": {
                      resource_group: "{{ resource_group }}",
                      name: "{{ account_name }}",
                      location: "{{ azure_location }}",
                      account_type: "Standard_LRS"
                    }
                  },
                  {
                    name: "Create blob container",
                    "azure.azcollection.azure_rm_storageblob": {
                      resource_group: "{{ resource_group }}",
                      storage_account_name: "{{ account_name }}",
                      container: "{{ container_name }}",
                      type: "container"
                    }
                  }
                ]
              }
            ];
          }
        },

        sql_db: {
          label: "SQL ‚Äì Server & database",
          description: "Create an Azure SQL logical server and a database.",
          inputs: [
            {
              id: "azure_location",
              label: "Azure location",
              control: "select",
              options: AZURE_LOCATIONS.map(l => ({ value: l, label: l })),
              default: "eastus",
              hint: "Region"
            },
            { id: "resource_group", label: "Resource group", type: "text", default: "rg-sql", hint: "Resource group name" },
            { id: "sql_server_name", label: "SQL server name", type: "text", default: "court-sql-srv", hint: "Globally unique DNS name" },
            { id: "admin_username", label: "Admin login", type: "text", default: "sqladmin", hint: "SQL admin login" },
            { id: "admin_password", label: "Admin password", type: "text", default: "CHANGE_ME!", hint: "Use secret in production" },
            { id: "db_name", label: "Database name", type: "text", default: "court", hint: "DB name" }
          ],
          buildPlay: (vals, hosts) => {
            return [
              {
                name: "Create Azure SQL server & DB",
                hosts,
                become: false,
                gather_facts: false,
                vars: {
                  azure_location: vals.azure_location,
                  resource_group: vals.resource_group,
                  sql_server_name: vals.sql_server_name,
                  admin_username: vals.admin_username,
                  admin_password: vals.admin_password,
                  db_name: vals.db_name
                },
                tasks: [
                  {
                    name: "Ensure resource group exists",
                    "azure.azcollection.azure_rm_resourcegroup": {
                      name: "{{ resource_group }}",
                      location: "{{ azure_location }}"
                    }
                  },
                  {
                    name: "Create SQL logical server",
                    "azure.azcollection.azure_rm_sqlserver": {
                      resource_group: "{{ resource_group }}",
                      name: "{{ sql_server_name }}",
                      location: "{{ azure_location }}",
                      admin_username: "{{ admin_username }}",
                      admin_password: "{{ admin_password }}"
                    }
                  },
                  {
                    name: "Create SQL database",
                    "azure.azcollection.azure_rm_sqldatabase": {
                      resource_group: "{{ resource_group }}",
                      server_name: "{{ sql_server_name }}",
                      name: "{{ db_name }}",
                      edition: "Standard",
                      requested_service_objective_name: "S0"
                    }
                  }
                ]
              }
            ];
          }
        },

        app_service: {
          label: "App Service ‚Äì Web App",
          description: "Create an App Service plan and a Linux Web App.",
          inputs: [
            {
              id: "azure_location",
              label: "Azure location",
              control: "select",
              options: AZURE_LOCATIONS.map(l => ({ value: l, label: l })),
              default: "eastus",
              hint: "Region"
            },
            { id: "resource_group", label: "Resource group", type: "text", default: "rg-apps", hint: "Resource group" },
            { id: "plan_name", label: "App Service plan name", type: "text", default: "court-plan", hint: "Plan name" },
            { id: "sku", label: "SKU", type: "text", default: "B1", hint: "e.g. F1, B1, P1v3" },
            { id: "webapp_name", label: "Web app name", type: "text", default: "court-webapp", hint: "Unique webapp name" },
            { id: "runtime_stack", label: "Runtime stack", type: "text", default: "DOTNETCORE|6.0", hint: "Linux runtime (e.g. DOTNETCORE|6.0)" }
          ],
          buildPlay: (vals, hosts) => {
            return [
              {
                name: "Create Azure App Service Web App",
                hosts,
                become: false,
                gather_facts: false,
                vars: {
                  azure_location: vals.azure_location,
                  resource_group: vals.resource_group,
                  plan_name: vals.plan_name,
                  sku: vals.sku,
                  webapp_name: vals.webapp_name,
                  runtime_stack: vals.runtime_stack
                },
                tasks: [
                  {
                    name: "Ensure resource group exists",
                    "azure.azcollection.azure_rm_resourcegroup": {
                      name: "{{ resource_group }}",
                      location: "{{ azure_location }}"
                    }
                  },
                  {
                    name: "Create App Service plan",
                    "azure.azcollection.azure_rm_appserviceplan": {
                      resource_group: "{{ resource_group }}",
                      name: "{{ plan_name }}",
                      location: "{{ azure_location }}",
                      sku: "{{ sku }}",
                      is_linux: true
                    }
                  },
                  {
                    name: "Create Web App",
                    "azure.azcollection.azure_rm_webapp": {
                      resource_group: "{{ resource_group }}",
                      name: "{{ webapp_name }}",
                      plan: "{{ plan_name }}",
                      location: "{{ azure_location }}",
                      linux_fx_version: "{{ runtime_stack }}"
                    }
                  }
                ]
              }
            ];
          }
        },

        aks_cluster: {
          label: "AKS ‚Äì Kubernetes cluster",
          description: "Create a basic AKS cluster.",
          inputs: [
            {
              id: "azure_location",
              label: "Azure location",
              control: "select",
              options: AZURE_LOCATIONS.map(l => ({ value: l, label: l })),
              default: "eastus",
              hint: "Region"
            },
            { id: "resource_group", label: "Resource group", type: "text", default: "rg-aks", hint: "Resource group" },
            { id: "aks_name", label: "AKS cluster name", type: "text", default: "court-aks", hint: "Cluster name" },
            {
              id: "node_count",
              label: "Node count",
              type: "number",
              default: 3,
              hint: "Number of nodes"
            },
            { id: "node_vm_size", label: "Node VM size", type: "text", default: "Standard_DS2_v2", hint: "VM size" }
          ],
          buildPlay: (vals, hosts) => {
            return [
              {
                name: "Create AKS cluster",
                hosts,
                become: false,
                gather_facts: false,
                vars: {
                  azure_location: vals.azure_location,
                  resource_group: vals.resource_group,
                  aks_name: vals.aks_name,
                  node_count: Number(vals.node_count),
                  node_vm_size: vals.node_vm_size
                },
                tasks: [
                  {
                    name: "Ensure resource group exists",
                    "azure.azcollection.azure_rm_resourcegroup": {
                      name: "{{ resource_group }}",
                      location: "{{ azure_location }}"
                    }
                  },
                  {
                    name: "Create AKS cluster",
                    "azure.azcollection.azure_rm_aks": {
                      resource_group: "{{ resource_group }}",
                      name: "{{ aks_name }}",
                      location: "{{ azure_location }}",
                      dns_prefix: "{{ aks_name }}",
                      kubernetes_version: "",
                      agent_pool_profiles: [
                        {
                          name: "nodepool1",
                          count: "{{ node_count }}",
                          vm_size: "{{ node_vm_size }}",
                          os_type: "Linux"
                        }
                      ]
                    }
                  }
                ]
              }
            ];
          }
        },

        log_analytics: {
          label: "Monitor ‚Äì Log Analytics workspace",
          description: "Create a Log Analytics workspace for monitoring.",
          inputs: [
            {
              id: "azure_location",
              label: "Azure location",
              control: "select",
              options: AZURE_LOCATIONS.map(l => ({ value: l, label: l })),
              default: "eastus",
              hint: "Region"
            },
            { id: "resource_group", label: "Resource group", type: "text", default: "rg-monitor", hint: "Resource group" },
            { id: "workspace_name", label: "Workspace name", type: "text", default: "court-laworkspace", hint: "Log Analytics workspace" }
          ],
          buildPlay: (vals, hosts) => {
            return [
              {
                name: "Create Log Analytics workspace",
                hosts,
                become: false,
                gather_facts: false,
                vars: {
                  azure_location: vals.azure_location,
                  resource_group: vals.resource_group,
                  workspace_name: vals.workspace_name
                },
                tasks: [
                  {
                    name: "Ensure resource group exists",
                    "azure.azcollection.azure_rm_resourcegroup": {
                      name: "{{ resource_group }}",
                      location: "{{ azure_location }}"
                    }
                  },
                  {
                    name: "Create Log Analytics workspace",
                    "azure.azcollection.azure_rm_loganalyticsworkspace": {
                      resource_group: "{{ resource_group }}",
                      name: "{{ workspace_name }}",
                      location: "{{ azure_location }}"
                    }
                  }
                ]
              }
            ];
          }
        },

        key_vault: {
          label: "Security ‚Äì Key Vault",
          description: "Create a Key Vault and a sample secret.",
          inputs: [
            {
              id: "azure_location",
              label: "Azure location",
              control: "select",
              options: AZURE_LOCATIONS.map(l => ({ value: l, label: l })),
              default: "eastus",
              hint: "Region"
            },
            { id: "resource_group", label: "Resource group", type: "text", default: "rg-secrets", hint: "Resource group" },
            { id: "vault_name", label: "Key Vault name", type: "text", default: "court-kv", hint: "Vault name (globally unique DNS)" },
            { id: "secret_name", label: "Secret name", type: "text", default: "db-password", hint: "Secret name" },
            { id: "secret_value", label: "Secret value", type: "text", default: "ChangeMe!", hint: "Use a secure value / vault" }
          ],
          buildPlay: (vals, hosts) => {
            return [
              {
                name: "Create Key Vault & secret",
                hosts,
                become: false,
                gather_facts: false,
                vars: {
                  azure_location: vals.azure_location,
                  resource_group: vals.resource_group,
                  vault_name: vals.vault_name,
                  secret_name: vals.secret_name,
                  secret_value: vals.secret_value
                },
                tasks: [
                  {
                    name: "Ensure resource group exists",
                    "azure.azcollection.azure_rm_resourcegroup": {
                      name: "{{ resource_group }}",
                      location: "{{ azure_location }}"
                    }
                  },
                  {
                    name: "Create Key Vault",
                    "azure.azcollection.azure_rm_keyvault": {
                      resource_group: "{{ resource_group }}",
                      name: "{{ vault_name }}",
                      location: "{{ azure_location }}"
                    }
                  },
                  {
                    name: "Create secret",
                    "azure.azcollection.azure_keyvaultsecret": {
                      vault_uri: "https://{{ vault_name }}.vault.azure.net",
                      secret_name: "{{ secret_name }}",
                      secret_value: "{{ secret_value }}"
                    }
                  }
                ]
              }
            ];
          }
        }
      }
    },

    gcp: {
      label: "Google Cloud Platform",
      scenarios: {
        gce_instance: {
          label: "Compute Engine ‚Äì VM instance",
          description: "Create a GCE instance in a specified project and zone.",
          inputs: [
            { id: "project_id", label: "Project ID", type: "text", default: "my-gcp-project", hint: "GCP project" },
            {
              id: "zone",
              label: "Zone",
              control: "select",
              options: GCP_ZONES.map(z => ({ value: z, label: z })),
              default: "us-central1-a",
              hint: "GCE zone"
            },
            { id: "instance_name", label: "Instance name", type: "text", default: "gce-ansible-01", hint: "VM name" },
            { id: "machine_type", label: "Machine type", type: "text", default: "e2-medium", hint: "e2-medium, n2-standard-2, etc." },
            { id: "image_family", label: "Image family", type: "text", default: "debian-11", hint: "debian-11, ubuntu-2004-lts, etc." },
            { id: "image_project", label: "Image project", type: "text", default: "debian-cloud", hint: "debian-cloud, ubuntu-os-cloud, etc." }
          ],
          buildPlay: (vals, hosts) => {
            return [
              {
                name: "Provision GCE instance",
                hosts,
                become: false,
                gather_facts: false,
                vars: {
                  gcp_project: vals.project_id,
                  gcp_zone: vals.zone,
                  instance_name: vals.instance_name,
                  machine_type: vals.machine_type,
                  image_family: vals.image_family,
                  image_project: vals.image_project
                },
                tasks: [
                  {
                    name: "Create GCE instance",
                    "google.cloud.gcp_compute_instance": {
                      name: "{{ instance_name }}",
                      project: "{{ gcp_project }}",
                      zone: "{{ gcp_zone }}",
                      machine_type: "{{ machine_type }}",
                      disks: [
                        {
                          auto_delete: true,
                          boot: true,
                          initialize_params: {
                            source_image: "projects/{{ image_project }}/global/images/family/{{ image_family }}"
                          }
                        }
                      ],
                      network_interfaces: [
                        {
                          network: "default",
                          access_configs: [{ name: "External NAT", type: "ONE_TO_ONE_NAT" }]
                        }
                      ]
                    }
                  }
                ]
              }
            ];
          }
        },
        gcs_bucket: {
          label: "Cloud Storage ‚Äì Bucket",
          description: "Create a Google Cloud Storage bucket.",
          inputs: [
            { id: "project_id", label: "Project ID", type: "text", default: "my-gcp-project", hint: "GCP project" },
            { id: "bucket_name", label: "Bucket name", type: "text", default: "court-archive-gcs", hint: "Globally unique" },
            { id: "location", label: "Location", type: "text", default: "US", hint: "US, EU, regional code, etc." }
          ],
          buildPlay: (vals, hosts) => {
            return [
              {
                name: "Create GCS bucket",
                hosts,
                become: false,
                gather_facts: false,
                vars: {
                  gcp_project: vals.project_id,
                  bucket_name: vals.bucket_name,
                  bucket_location: vals.location
                },
                tasks: [
                  {
                    name: "Create bucket",
                    "google.cloud.gcp_storage_bucket": {
                      name: "{{ bucket_name }}",
                      project: "{{ gcp_project }}",
                      location: "{{ bucket_location }}"
                    }
                  }
                ]
              }
            ];
          }
        },
        pubsub_topic: {
          label: "Pub/Sub ‚Äì Topic",
          description: "Create a Pub/Sub topic.",
          inputs: [
            { id: "project_id", label: "Project ID", type: "text", default: "my-gcp-project", hint: "GCP project" },
            { id: "topic_name", label: "Topic name", type: "text", default: "court-events", hint: "Topic ID" }
          ],
          buildPlay: (vals, hosts) => {
            return [
              {
                name: "Create Pub/Sub topic",
                hosts,
                become: false,
                gather_facts: false,
                vars: {
                  gcp_project: vals.project_id,
                  topic_name: vals.topic_name
                },
                tasks: [
                  {
                    name: "Ensure topic exists",
                    "google.cloud.gcp_pubsub_topic": {
                      name: "{{ topic_name }}",
                      project: "{{ gcp_project }}"
                    }
                  }
                ]
              }
            ];
          }
        }
      }
    },

    oci: {
      label: "Oracle Cloud Infrastructure (OCI)",
      scenarios: {
        compute_instance: {
          label: "Compute ‚Äì VM instance",
          description: "Create an OCI compute instance in a given compartment and subnet.",
          inputs: [
            { id: "compartment_ocid", label: "Compartment OCID", type: "text", default: "ocid1.compartment.oc1..xxxxx", hint: "Target compartment" },
            { id: "availability_domain", label: "Availability Domain", type: "text", default: "AD-1", hint: "AD name (e.g. Uocm:US-ASHBURN-AD-1)" },
            { id: "subnet_ocid", label: "Subnet OCID", type: "text", default: "ocid1.subnet.oc1..xxxxx", hint: "Target subnet" },
            { id: "display_name", label: "Instance display name", type: "text", default: "oci-ansible-01", hint: "Human-friendly name" },
            { id: "shape", label: "Shape", type: "text", default: "VM.Standard.E4.Flex", hint: "Compute shape" },
            { id: "image_ocid", label: "Image OCID", type: "text", default: "ocid1.image.oc1..xxxxx", hint: "OS image" }
          ],
          buildPlay: (vals, hosts) => {
            return [
              {
                name: "Provision OCI compute instance",
                hosts,
                become: false,
                gather_facts: false,
                vars: {
                  compartment_ocid: vals.compartment_ocid,
                  availability_domain: vals.availability_domain,
                  subnet_ocid: vals.subnet_ocid,
                  display_name: vals.display_name,
                  shape: vals.shape,
                  image_ocid: vals.image_ocid
                },
                tasks: [
                  {
                    name: "Create compute instance",
                    "oracle.oci.oci_compute_instance": {
                      availability_domain: "{{ availability_domain }}",
                      compartment_id: "{{ compartment_ocid }}",
                      display_name: "{{ display_name }}",
                      shape: "{{ shape }}",
                      create_vnic_details: {
                        subnet_id: "{{ subnet_ocid }}"
                      },
                      source_details: {
                        source_type: "image",
                        image_id: "{{ image_ocid }}"
                      }
                    }
                  }
                ]
              }
            ];
          }
        },
        object_bucket: {
          label: "Object Storage ‚Äì Bucket",
          description: "Create an OCI Object Storage bucket.",
          inputs: [
            { id: "compartment_ocid", label: "Compartment OCID", type: "text", default: "ocid1.compartment.oc1..xxxxx", hint: "Target compartment" },
            { id: "namespace", label: "Object storage namespace", type: "text", default: "mytenancy", hint: "Get from OCI console" },
            { id: "bucket_name", label: "Bucket name", type: "text", default: "court-archive-oci", hint: "Bucket name" }
          ],
          buildPlay: (vals, hosts) => {
            return [
              {
                name: "Create OCI object storage bucket",
                hosts,
                become: false,
                gather_facts: false,
                vars: {
                  compartment_ocid: vals.compartment_ocid,
                  namespace: vals.namespace,
                  bucket_name: vals.bucket_name
                },
                tasks: [
                  {
                    name: "Ensure bucket exists",
                    "oracle.oci.oci_object_storage_bucket": {
                      compartment_id: "{{ compartment_ocid }}",
                      namespace_name: "{{ namespace }}",
                      name: "{{ bucket_name }}"
                    }
                  }
                ]
              }
            ];
          }
        }
      }
    },

    vmware: {
      label: "VMware vSphere",
      scenarios: {
        vmware_guest: {
          label: "VM ‚Äì Clone from template",
          description: "Clone and customize a VM from a template using community.vmware.vmware_guest.",
          inputs: [
            { id: "vcenter_hostname", label: "vCenter hostname", type: "text", default: "vcenter.example.com", hint: "FQDN or IP" },
            { id: "datacenter", label: "Datacenter name", type: "text", default: "Datacenter-1", hint: "Existing DC" },
            { id: "cluster", label: "Cluster name", type: "text", default: "Cluster-1", hint: "Target cluster" },
            { id: "template", label: "Template name", type: "text", default: "tmpl-linux-gold", hint: "Template to clone" },
            { id: "vm_name", label: "New VM name", type: "text", default: "vm-linux-01", hint: "Target VM name" },
            { id: "datastore", label: "Datastore name", type: "text", default: "Datastore-1", hint: "Target datastore" }
          ],
          buildPlay: (vals, hosts) => {
            return [
              {
                name: "Provision vSphere VM",
                hosts,
                become: false,
                gather_facts: false,
                vars: {
                  vcenter_hostname: vals.vcenter_hostname,
                  datacenter: vals.datacenter,
                  cluster: vals.cluster,
                  template: vals.template,
                  vm_name: vals.vm_name,
                  datastore: vals.datastore
                },
                tasks: [
                  {
                    name: "Clone VM from template",
                    "community.vmware.vmware_guest": {
                      hostname: "{{ vcenter_hostname }}",
                      validate_certs: false,
                      datacenter: "{{ datacenter }}",
                      cluster: "{{ cluster }}",
                      name: "{{ vm_name }}",
                      template: "{{ template }}",
                      datastore: "{{ datastore }}",
                      state: "poweredon",
                      wait_for_ip_address: true
                    }
                  }
                ]
              }
            ];
          }
        },
        snapshot_vm: {
          label: "VM ‚Äì Snapshot",
          description: "Create a snapshot for a vSphere VM.",
          inputs: [
            { id: "vcenter_hostname", label: "vCenter hostname", type: "text", default: "vcenter.example.com", hint: "FQDN or IP" },
            { id: "datacenter", label: "Datacenter name", type: "text", default: "Datacenter-1", hint: "Existing DC" },
            { id: "vm_name", label: "VM name", type: "text", default: "vm-linux-01", hint: "VM to snapshot" },
            { id: "snapshot_name", label: "Snapshot name", type: "text", default: "pre-change", hint: "Snapshot label" },
            { id: "snapshot_desc", label: "Snapshot description", type: "text", default: "Before change window", hint: "Optional description" }
          ],
          buildPlay: (vals, hosts) => {
            return [
              {
                name: "Create vSphere VM snapshot",
                hosts,
                become: false,
                gather_facts: false,
                vars: {
                  vcenter_hostname: vals.vcenter_hostname,
                  datacenter: vals.datacenter,
                  vm_name: vals.vm_name,
                  snapshot_name: vals.snapshot_name,
                  snapshot_desc: vals.snapshot_desc
                },
                tasks: [
                  {
                    name: "Create snapshot",
                    "community.vmware.vmware_guest_snapshot": {
                      hostname: "{{ vcenter_hostname }}",
                      validate_certs: false,
                      datacenter: "{{ datacenter }}",
                      name: "{{ vm_name }}",
                      state: "present",
                      snapshot_name: "{{ snapshot_name }}",
                      description: "{{ snapshot_desc }}"
                    }
                  }
                ]
              }
            ];
          }
        }
      }
    },

    linux: {
      label: "Generic Linux hosts",
      scenarios: {
        nginx_server: {
          label: "Web ‚Äì NGINX server",
          description: "Install NGINX, enable service, and deploy a simple index page.",
          inputs: [
            {
              id: "http_port",
              label: "HTTP port",
              type: "number",
              default: "80",
              hint: "e.g. 80, 8080"
            },
            {
              id: "index_message",
              label: "Index page message",
              type: "text",
              default: "Hello from Ansible",
              hint: "Simple banner text"
            }
          ],
          buildPlay: (vals, hosts) => {
            return [
              {
                name: "Configure NGINX web server",
                hosts,
                become: true,
                vars: {
                  index_message: vals.index_message
                },
                tasks: [
                  {
                    name: "Install NGINX",
                    "ansible.builtin.package": {
                      name: "nginx",
                      state: "present"
                    }
                  },
                  {
                    name: "Ensure NGINX running and enabled",
                    "ansible.builtin.service": {
                      name: "nginx",
                      state: "started",
                      enabled: true
                    }
                  },
                  {
                    name: "Deploy index page",
                    "ansible.builtin.copy": {
                      dest: "/usr/share/nginx/html/index.html",
                      mode: "0644",
                      content: "<html><body><h1>{{ index_message }}</h1></body></html>"
                    }
                  }
                ]
              }
            ];
          }
        },
        linux_patch: {
          label: "Ops ‚Äì Security updates",
          description: "Run package updates and reboot if required.",
          inputs: [
            {
              id: "reboot_if_needed",
              label: "Reboot if kernel updated",
              control: "select",
              options: BOOL_OPTIONS,
              default: "true",
              hint: "true / false"
            }
          ],
          buildPlay: (vals, hosts) => {
            return [
              {
                name: "Apply Linux security updates",
                hosts,
                become: true,
                vars: {
                  reboot_if_needed: vals.reboot_if_needed === "true"
                },
                tasks: [
                  {
                    name: "Update packages to latest",
                    "ansible.builtin.package": {
                      name: "*",
                      state: "latest"
                    }
                  },
                  {
                    name: "Check if reboot is required (Debian/Ubuntu)",
                    "ansible.builtin.stat": {
                      path: "/var/run/reboot-required"
                    },
                    register: "reboot_required_file",
                    when: "ansible_os_family == 'Debian'"
                  },
                  {
                    name: "Reboot if needed",
                    "ansible.builtin.reboot": {},
                    when: "reboot_if_needed and reboot_required_file.stat.exists | default(false)"
                  }
                ]
              }
            ];
          }
        },
        linux_users: {
          label: "Identity ‚Äì Users & groups",
          description: "Manage local users, groups and SSH keys.",
          inputs: [
            { id: "group_name", label: "Group name", type: "text", default: "appusers", hint: "Primary group" },
            { id: "username", label: "User name", type: "text", default: "deploy", hint: "Login user" },
            {
              id: "shell",
              label: "Shell",
              control: "select",
              options: [
                { value: "/bin/bash", label: "/bin/bash" },
                { value: "/bin/zsh", label: "/bin/zsh" },
                { value: "/bin/sh", label: "/bin/sh" }
              ],
              default: "/bin/bash",
              hint: "Default shell"
            },
            { id: "ssh_pubkey", label: "SSH public key", type: "text", default: "ssh-ed25519 AAAA...", hint: "User key" }
          ],
          buildPlay: (vals, hosts) => {
            return [
              {
                name: "Create Linux users & groups",
                hosts,
                become: true,
                vars: {
                  group_name: vals.group_name,
                  username: vals.username,
                  user_shell: vals.shell,
                  ssh_pubkey: vals.ssh_pubkey
                },
                tasks: [
                  {
                    name: "Ensure group exists",
                    "ansible.builtin.group": {
                      name: "{{ group_name }}",
                      state: "present"
                    }
                  },
                  {
                    name: "Ensure user exists",
                    "ansible.builtin.user": {
                      name: "{{ username }}",
                      group: "{{ group_name }}",
                      shell: "{{ user_shell }}",
                      create_home: true
                    }
                  },
                  {
                    name: "Install authorized key",
                    "ansible.posix.authorized_key": {
                      user: "{{ username }}",
                      state: "present",
                      key: "{{ ssh_pubkey }}"
                    }
                  }
                ]
              }
            ];
          }
        },
        linux_cron_backup: {
          label: "Ops ‚Äì Cron job (backup script)",
          description: "Install a cron job to run a backup script on a schedule.",
          inputs: [
            { id: "user", label: "Run as user", type: "text", default: "root", hint: "User for cron" },
            { id: "job_name", label: "Job name", type: "text", default: "nightly-backup", hint: "Identifier" },
            { id: "schedule", label: "Cron schedule", type: "text", default: "0 2 * * *", hint: "Standard cron string" },
            { id: "command", label: "Command", type: "text", default: "/usr/local/bin/backup.sh", hint: "Script or command" }
          ],
          buildPlay: (vals, hosts) => {
            return [
              {
                name: "Configure backup cron job",
                hosts,
                become: true,
                vars: {
                  cron_user: vals.user,
                  job_name: vals.job_name,
                  schedule: vals.schedule,
                  command: vals.command
                },
                tasks: [
                  {
                    name: "Install cron job",
                    "ansible.builtin.cron": {
                      user: "{{ cron_user }}",
                      name: "{{ job_name }}",
                      job: "{{ command }}",
                      special_time: "absent",
                      minute: "{{ schedule.split(' ')[0] }}",
                      hour: "{{ schedule.split(' ')[1] }}",
                      day: "{{ schedule.split(' ')[2] }}",
                      month: "{{ schedule.split(' ')[3] }}",
                      weekday: "{{ schedule.split(' ')[4] }}"
                    }
                  }
                ]
              }
            ];
          }
        },
        linux_harden_ssh: {
          label: "Security ‚Äì Harden SSH",
          description: "Apply basic SSH hardening to sshd_config.",
          inputs: [
            {
              id: "allow_password_auth",
              label: "Allow password auth",
              control: "select",
              options: BOOL_OPTIONS,
              default: "false",
              hint: "Prefer false for security"
            }
          ],
          buildPlay: (vals, hosts) => {
            return [
              {
                name: "Harden SSH configuration",
                hosts,
                become: true,
                vars: {
                  allow_password_auth: vals.allow_password_auth === "true"
                },
                tasks: [
                  {
                    name: "Ensure SSHD config present",
                    "ansible.builtin.lineinfile": {
                      path: "/etc/ssh/sshd_config",
                      regexp: "^PasswordAuthentication",
                      line: "PasswordAuthentication {{ 'yes' if allow_password_auth else 'no' }}",
                      backup: true
                    }
                  },
                  {
                    name: "Disable root login via SSH",
                    "ansible.builtin.lineinfile": {
                      path: "/etc/ssh/sshd_config",
                      regexp: "^PermitRootLogin",
                      line: "PermitRootLogin prohibit-password",
                      backup: true
                    }
                  },
                  {
                    name: "Restart SSH service",
                    "ansible.builtin.service": {
                      name: "ssh",
                      state: "restarted"
                    },
                    when: "ansible_service_mgr != 'systemd' or ansible_os_family != 'RedHat'"
                  },
                  {
                    name: "Restart sshd service",
                    "ansible.builtin.service": {
                      name: "sshd",
                      state: "restarted"
                    },
                    when: "ansible_service_mgr == 'systemd' and ansible_os_family == 'RedHat'"
                  }
                ]
              }
            ];
          }
        }
      }
    },

    windows: {
      label: "Generic Windows hosts",
      scenarios: {
        join_domain: {
          label: "Identity ‚Äì Join to AD domain",
          description: "Join a Windows host to an Active Directory domain using win_domain_membership.",
          inputs: [
            { id: "domain_name", label: "Domain name", type: "text", default: "corp.example.com", hint: "FQDN" },
            { id: "ou_path", label: "OU path (optional)", type: "text", default: "OU=Servers,DC=corp,DC=example,DC=com", hint: "Can be blank" },
            { id: "domain_user", label: "Domain join user (UPN)", type: "text", default: "ansible-join@corp.example.com", hint: "UPN format" },
            {
              id: "reboot_after",
              label: "Reboot after join",
              control: "select",
              options: BOOL_OPTIONS,
              default: "true",
              hint: "true / false"
            }
          ],
          buildPlay: (vals, hosts) => {
            return [
              {
                name: "Join Windows servers to domain",
                hosts,
                gather_facts: false,
                vars: {
                  domain_name: vals.domain_name,
                  ou_path: vals.ou_path,
                  domain_user: vals.domain_user,
                  reboot_after: vals.reboot_after === "true"
                },
                tasks: [
                  {
                    name: "Join domain",
                    "ansible.windows.win_domain_membership": {
                      dns_domain_name: "{{ domain_name }}",
                      domain_admin_user: "{{ domain_user }}",
                      domain_admin_password: "{{ domain_join_password | default('CHANGEME') }}",
                      domain_ou_path: "{{ ou_path }}",
                      state: "domain"
                    },
                    register: "domain_state"
                  },
                  {
                    name: "Reboot if domain join changed and reboot_after is true",
                    "ansible.windows.win_reboot": {},
                    when: "reboot_after and domain_state.reboot_required"
                  }
                ]
              }
            ];
          }
        },
        install_iis: {
          label: "Web ‚Äì IIS server",
          description: "Enable IIS role and deploy a simple default page.",
          inputs: [
            { id: "site_name", label: "Site name", type: "text", default: "Default Web Site", hint: "IIS site" },
            { id: "index_message", label: "Index page message", type: "text", default: "Hello from Ansible on IIS", hint: "HTML content heading" }
          ],
          buildPlay: (vals, hosts) => {
            return [
              {
                name: "Install IIS",
                hosts,
                gather_facts: false,
                vars: {
                  index_message: vals.index_message
                },
                tasks: [
                  {
                    name: "Install IIS role",
                    "ansible.windows.win_feature": {
                      name: "Web-Server",
                      state: "present",
                      include_management_tools: true
                    }
                  },
                  {
                    name: "Ensure IIS service running",
                    "ansible.windows.win_service": {
                      name: "W3SVC",
                      state: "started",
                      start_mode: "auto"
                    }
                  },
                  {
                    name: "Deploy default page",
                    "ansible.windows.win_copy": {
                      dest: "C:\\inetpub\\wwwroot\\index.html",
                      content: "<html><body><h1>{{ index_message }}</h1></body></html>"
                    }
                  }
                ]
              }
            ];
          }
        },
        windows_updates: {
          label: "Ops ‚Äì Windows Updates",
          description: "Apply Windows Updates with optional reboot.",
          inputs: [
            {
              id: "category_names",
              label: "Update categories (comma-separated)",
              type: "text",
              default: "SecurityUpdates,CriticalUpdates",
              hint: "Use ALL for everything"
            },
            {
              id: "reboot_if_needed",
              label: "Reboot if required",
              control: "select",
              options: BOOL_OPTIONS,
              default: "true",
              hint: "true / false"
            }
          ],
          buildPlay: (vals, hosts) => {
            return [
              {
                name: "Apply Windows Updates",
                hosts,
                gather_facts: false,
                vars: {
                  categories_raw: vals.category_names,
                  reboot_if_needed: vals.reboot_if_needed === "true"
                },
                tasks: [
                  {
                    name: "Install updates",
                    "ansible.windows.win_updates": {
                      category_names: "{{ categories_raw.split(',') if categories_raw != 'ALL' else [] }}",
                      state: "installed"
                    },
                    register: "update_result"
                  },
                  {
                    name: "Reboot if required and allowed",
                    "ansible.windows.win_reboot": {},
                    when: "reboot_if_needed and update_result.reboot_required"
                  }
                ]
              }
            ];
          }
        },
        windows_local_user: {
          label: "Identity ‚Äì Local user",
          description: "Create or update a local Windows user.",
          inputs: [
            { id: "username", label: "Username", type: "text", default: "svc_ansible", hint: "Local account" },
            { id: "password", label: "Password", type: "text", default: "CHANGE_ME!", hint: "Use vault/secret in real life" },
            {
              id: "group",
              label: "Primary group",
              type: "text",
              default: "Users",
              hint: "e.g. Administrators, Users"
            }
          ],
          buildPlay: (vals, hosts) => {
            return [
              {
                name: "Manage local Windows user",
                hosts,
                gather_facts: false,
                vars: {
                  username: vals.username,
                  password: vals.password,
                  group: vals.group
                },
                tasks: [
                  {
                    name: "Ensure user exists",
                    "ansible.windows.win_user": {
                      name: "{{ username }}",
                      password: "{{ password }}",
                      groups: "{{ group }}",
                      state: "present"
                    }
                  }
                ]
              }
            ];
          }
        }
      }
    }
  };

  // -----------------------
  // Simple YAML serializer (for our limited structures)
  // -----------------------
  function toYaml(value, indent = 0) {
    const pad = "  ".repeat(indent);

    if (value === null || value === undefined) {
      return "null";
    }
    if (typeof value === "string") {
      if (/[:{}\[\],&*#?|<>=!%@`\\]/.test(value) || value.trim() !== value || value.includes("\n")) {
        return JSON.stringify(value);
      }
      return value;
    }
    if (typeof value === "number" || typeof value === "boolean") {
      return String(value);
    }
    if (Array.isArray(value)) {
      if (value.length === 0) return "[]";
      return value
        .map(item => pad + "- " + toYaml(item, indent + 1).replace(/^\s+/, ""))
        .join("\n");
    }
    if (typeof value === "object") {
      const keys = Object.keys(value);
      if (keys.length === 0) return "{}";
      return keys
        .map(key => {
          const v = value[key];
          const keyStr = String(key);
          if (
            v === null ||
            typeof v === "string" ||
            typeof v === "number" ||
            typeof v === "boolean"
          ) {
            return pad + keyStr + ": " + toYaml(v, indent + 1);
          } else {
            const nested = toYaml(v, indent + 1);
            return pad + keyStr + ":\n" + nested;
          }
        })
        .join("\n");
    }
    return JSON.stringify(value);
  }

  // -----------------------
  // UI wiring
  // -----------------------
  const platformSelect = document.getElementById("platformSelect");
  const scenarioSelect = document.getElementById("scenarioSelect");
  const paramsArea = document.getElementById("paramsArea");
  const generateButton = document.getElementById("generateButton");
  const resetButton = document.getElementById("resetButton");
  const formatToggle = document.getElementById("formatToggle");
  const outputPre = document.getElementById("outputPre");
  const codeMeta = document.getElementById("codeMeta");
  const filenameInput = document.getElementById("filenameInput");
  const hostsInput = document.getElementById("hostsInput");
  const downloadButton = document.getElementById("downloadButton");
  const copyButton = document.getElementById("copyButton");
  const copyCommandButton = document.getElementById("copyCommandButton");
  const commandHint = document.getElementById("commandHint");
  const statusLine = document.getElementById("statusLine");

  let currentFormat = "yaml";

  function initSelectors() {
    platformSelect.innerHTML = "";
    Object.entries(SCENARIO_DEFS).forEach(([id, def]) => {
      const opt = document.createElement("option");
      opt.value = id;
      opt.textContent = def.label;
      platformSelect.appendChild(opt);
    });
    loadScenariosForPlatform(platformSelect.value);
  }

  function loadScenariosForPlatform(platformId) {
    const platform = SCENARIO_DEFS[platformId];
    scenarioSelect.innerHTML = "";
    if (!platform) return;
    Object.entries(platform.scenarios).forEach(([id, sc]) => {
      const opt = document.createElement("option");
      opt.value = id;
      opt.textContent = sc.label;
      scenarioSelect.appendChild(opt);
    });
    renderParams(platformId, scenarioSelect.value);
  }

  function renderParams(platformId, scenarioId) {
    const platform = SCENARIO_DEFS[platformId];
    const scenario = platform && platform.scenarios[scenarioId];
    paramsArea.innerHTML = "";
    if (!scenario) return;

    const desc = document.createElement("p");
    desc.className = "hint";
    desc.textContent = scenario.description || "";
    paramsArea.appendChild(desc);

    scenario.inputs.forEach(input => {
      const field = document.createElement("div");
      field.className = "field";

      const labelRow = document.createElement("div");
      labelRow.className = "field-label-row";

      const label = document.createElement("label");
      label.htmlFor = input.id;
      label.textContent = input.label;

      const hintSpan = document.createElement("span");
      hintSpan.className = "hint";
      hintSpan.textContent = input.hint || "";

      labelRow.appendChild(label);
      labelRow.appendChild(hintSpan);
      field.appendChild(labelRow);

      if (input.control === "select" && Array.isArray(input.options)) {
        const selectEl = document.createElement("select");
        selectEl.id = input.id;
        input.options.forEach(optDef => {
          const opt = document.createElement("option");
          opt.value = optDef.value;
          opt.textContent = optDef.label;
          selectEl.appendChild(opt);
        });
        if (input.default !== undefined) {
          selectEl.value = input.default;
        }
        field.appendChild(selectEl);
      } else {
        const inputEl = document.createElement("input");
        inputEl.type = input.type || "text";
        inputEl.id = input.id;
        inputEl.value = input.default || "";
        field.appendChild(inputEl);
      }

      paramsArea.appendChild(field);
    });
  }

  function collectValues(platformId, scenarioId) {
    const platform = SCENARIO_DEFS[platformId];
    const scenario = platform && platform.scenarios[scenarioId];
    const values = {};
    if (!scenario) return values;
    scenario.inputs.forEach(input => {
      const el = document.getElementById(input.id);
      values[input.id] = el ? el.value : "";
    });
    return values;
  }

  function safeUpdateStatus(ok, msg) {
    const dot = statusLine.querySelector(".status-dot");
    const textNode = statusLine.querySelector("span:nth-child(2)");
    if (!dot || !textNode) return;
    dot.classList.toggle("error", !ok);
    textNode.textContent = msg;
    if (!ok) {
      textNode.classList.add("error-text");
    } else {
      textNode.classList.remove("error-text");
    }
  }

  function generatePlaybook() {
    const platformId = platformSelect.value;
    const scenarioId = scenarioSelect.value;
    const hosts = hostsInput.value || "all";
    const platform = SCENARIO_DEFS[platformId];
    const scenario = platform && platform.scenarios[scenarioId];

    if (!scenario) {
      outputPre.textContent = "# No service / blueprint selected.";
      safeUpdateStatus(false, "No service / blueprint selected.");
      return;
    }

    const vals = collectValues(platformId, scenarioId);
    let playbook;
    try {
      playbook = scenario.buildPlay(vals, hosts);
    } catch (e) {
      outputPre.textContent = "# Error building playbook: " + e.message;
      safeUpdateStatus(false, "Error building playbook. Check console.");
      console.error("buildPlay error", e);
      return;
    }

    let text;
    if (currentFormat === "json") {
      text = JSON.stringify(playbook, null, 2);
    } else {
      text = toYaml(playbook, 0);
    }
    outputPre.textContent = text;

    const filename = filenameInput.value || (currentFormat === "yaml" ? "playbook_generated.yml" : "playbook_generated.json");
    commandHint.textContent = `ansible-playbook -i inventory.yml ${filename}`;
    codeMeta.textContent = `${platform.label} ¬∑ ${scenario.label} ¬∑ Format: ${currentFormat.toUpperCase()}`;
    safeUpdateStatus(true, "Playbook generated successfully.");
  }

  function handleDownload() {
    const filename = filenameInput.value || (currentFormat === "yaml" ? "playbook_generated.yml" : "playbook_generated.json");
    const blob = new Blob([outputPre.textContent], {
      type: currentFormat === "yaml" ? "text/yaml" : "application/json"
    });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  function handleCopyCode() {
    navigator.clipboard.writeText(outputPre.textContent).then(() => {
      safeUpdateStatus(true, "Playbook copied to clipboard.");
    }).catch(() => {
      safeUpdateStatus(false, "Unable to copy playbook.");
    });
  }

  function handleCopyCommand() {
    navigator.clipboard.writeText(commandHint.textContent).then(() => {
      safeUpdateStatus(true, "Command copied to clipboard.");
    }).catch(() => {
      safeUpdateStatus(false, "Unable to copy command.");
    });
  }

  function handleFormatToggle(ev) {
    const btn = ev.target.closest("button[data-format]");
    if (!btn) return;
    const fmt = btn.getAttribute("data-format");
    if (!fmt || fmt === currentFormat) return;
    currentFormat = fmt;
    Array.from(formatToggle.querySelectorAll("button[data-format]")).forEach(b => {
      b.classList.toggle("active", b.getAttribute("data-format") === currentFormat);
    });
    generatePlaybook();
  }

  function resetAll() {
    hostsInput.value = "all";
    filenameInput.value = "playbook_generated.yml";
    initSelectors();
    outputPre.textContent = "# Select a platform & service / blueprint, adjust parameters, then click ‚ÄúGenerate Playbook‚Äù.";
    commandHint.textContent = "ansible-playbook -i inventory.yml playbook_generated.yml";
    codeMeta.textContent = "Waiting for input‚Ä¶";
    safeUpdateStatus(true, "Reset to defaults.");
  }

  document.addEventListener("DOMContentLoaded", () => {
    initSelectors();
    generateButton.addEventListener("click", generatePlaybook);
    resetButton.addEventListener("click", resetAll);
    platformSelect.addEventListener("change", () => {
      loadScenariosForPlatform(platformSelect.value);
      safeUpdateStatus(true, "Platform changed; service / blueprint & parameters updated.");
    });
    scenarioSelect.addEventListener("change", () => {
      renderParams(platformSelect.value, scenarioSelect.value);
      safeUpdateStatus(true, "Service / blueprint changed; review parameters.");
    });
    formatToggle.addEventListener("click", handleFormatToggle);
    downloadButton.addEventListener("click", handleDownload);
    copyButton.addEventListener("click", handleCopyCode);
    copyCommandButton.addEventListener("click", handleCopyCommand);
  });
</script>
</body>
</html>
